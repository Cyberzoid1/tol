Comparing files TOL_EDITOR\animation.cpp and TOL_EDITOR_MASTER\animation.cpp
***** TOL_EDITOR\animation.cpp
/**
* CS 383
* Group #4
* Created: 11/05/2016
*
* This file contains the method definitions for the Animation class.
*/
***** TOL_EDITOR_MASTER\animation.cpp
/**
* @class Animation
*/
*****

***** TOL_EDITOR\animation.cpp
/**
 * Construct a new Animation with the default values.
 */
***** TOL_EDITOR_MASTER\animation.cpp
/**
 * Construct a new Animation with the following default values;
 * version: 0.4, filename: (empty string), height: 10. width: 4.
 */
*****

***** TOL_EDITOR\animation.cpp
        version = "0.4";
        filename = "";
    numFrames = (int)frames.size();
***** TOL_EDITOR_MASTER\animation.cpp
        version = "0.4";
    filename = "NoAudioFile";
    numFrames = (int)frames.size();
*****

***** TOL_EDITOR\animation.cpp
/**
 * TODO: determine what we want setFrames to do
 * @param frms list of Frames
 */
***** TOL_EDITOR_MASTER\animation.cpp
/**
 * Set the list of frames in the animation and update numFrames.
 * @param frms List of Frames
 * @return Void.
 */
*****

***** TOL_EDITOR\animation.cpp
    frames = frms;
}
/**
 * Return the list of frames from the Animation.
 */
***** TOL_EDITOR_MASTER\animation.cpp
    frames = frms;
    numFrames = (int)frames.size();
}

/**
 * Returns a copy of the frames that make up the current animation.
 * @return STL List containing frame objects with a length equal to the
 * current number of frames in the animation.
 */
*****

***** TOL_EDITOR\animation.cpp
 * Set the Animation's version number.
 * @param ver
 */
***** TOL_EDITOR_MASTER\animation.cpp
 * Set the Animation's version number.
 * @param ver String representation of the version being used for
 * the .tan2 file.
 * @return Void.
 */
*****

***** TOL_EDITOR\animation.cpp
}
/**
 * Return the animation's version.
 */
***** TOL_EDITOR_MASTER\animation.cpp
}

/**
 * Returns the animation's version.
 * @return A string object representing the animations version number.
 */
*****

***** TOL_EDITOR\animation.cpp
 * and then set the Animation's filename.
 * @param fname specified filename
 */
***** TOL_EDITOR_MASTER\animation.cpp
 * and then set the Animation's filename.
 * @param fname specified filename.
 * @return Void.
 */
*****

***** TOL_EDITOR\animation.cpp
/**
 * Return the Animation's filename.
 */
***** TOL_EDITOR_MASTER\animation.cpp
/**
 * Returns the file name associated with the animation.
 * @return A string object containing the filename.
 */
*****

***** TOL_EDITOR\animation.cpp
}
/**
 * Set the last color used on the Animation in the editor.
 * @param red [0-255]
 * @param green [0-255]
 * @param blue [0-255]
 */
***** TOL_EDITOR_MASTER\animation.cpp
}

/**
 * Sets the last color used while creating the animation.
 * @param red An integer representation of the red component.
 * @param green An integer representation of the green component.
 * @param blue An integer representation of the blue component.
 * @return Void.
 */
*****

***** TOL_EDITOR\animation.cpp
/**
 * Return the last color used on the Animation in the editor.
 */
***** TOL_EDITOR_MASTER\animation.cpp
/**
 * Returns the last color used while creating the current animation.
 * @return A copy of an RGB Object containing the color data.
 */
*****

***** TOL_EDITOR\animation.cpp
/**
 * Return a pointer to the array of recently used colors.
 */
***** TOL_EDITOR_MASTER\animation.cpp
/**
 * We need to look at what this does
 */
*****

***** TOL_EDITOR\animation.cpp
/**
 * Return the number of frames in the Animation.
 */
***** TOL_EDITOR_MASTER\animation.cpp
/**
 * Returns the current number of frames used in the Animation.
 * @return An int value representing the number of frames used
 * in the current animation.
 */
*****

***** TOL_EDITOR\animation.cpp
/**
 * Set the height of the animation.
 * @param h number of columns
 */
***** TOL_EDITOR_MASTER\animation.cpp
/**
 * Set the number of cells that comprise the height of the animation frame.
 * @param h Number of cell objects in a column.
 */
*****

***** TOL_EDITOR\animation.cpp
/**
 * Return the height of the Animation.
 */
***** TOL_EDITOR_MASTER\animation.cpp
/**
 * Returns the number of cells that make up the column of a frame.
 * @return An integer value representing the number of cell
 * objects per column.
 */
*****

***** TOL_EDITOR\animation.cpp
}
/**
 * Set the width of the Animation.
 * @param w number of rows
 */
***** TOL_EDITOR_MASTER\animation.cpp
}

/**
 * Set the number of cells that comprise the width of the animation frame.
 * @param h Number of cell objects in a row.
 */
*****

***** TOL_EDITOR\animation.cpp
}
/**
 * Return the width of the Animation.
 */
***** TOL_EDITOR_MASTER\animation.cpp
}

/**
 * Returns the number of cells that make up the row of a frame.
 * @return An integer value representing the number of cell
 * objects per row.
 */
*****

***** TOL_EDITOR\animation.cpp
}
/**
 * Add an empty frame to the specified location in the Animation.
 * @param w width of the frame
 * @param h height of the frame
 * @param pos position to add the frame at
 */
***** TOL_EDITOR_MASTER\animation.cpp
}

/**
 * Add an empty frame object to the specified location in the Animation.
 * @param w Width of the frame in cells.
 * @param h Height of the frame in cells.
 * @param pos Index of the position to add the frame
 * @return Void.
 */
*****

***** TOL_EDITOR\animation.cpp
}
/**
 * Add a copy of the specified frame right after it.
 * @param frame
 */
***** TOL_EDITOR_MASTER\animation.cpp
}

/**
 * Creates a copy of the frame passed into the method then inserts
 * it directly after the frame that was duplicated.
 * @param frame The frame object to duplicate.
 * @return Void.
 */
*****

***** TOL_EDITOR\animation.cpp
}
/**
 * Remove a frame at the specified position.
 * @param pos position
 */
***** TOL_EDITOR_MASTER\animation.cpp
}

/**
 * Removes a frame at the specified position within the frame list.
 * @param pos Index position of the frame to remove.
 * @return Void.
 */
*****

***** TOL_EDITOR\animation.cpp
}
/**
 * Remove the frames between the specified indices (inclusive).
 * @param start starting index
 * @param stop ending index
 */
***** TOL_EDITOR_MASTER\animation.cpp
}

/**
 * Removes all of the frames between the specified indices from the
 * frame list (inclusive).
 * @param start Index of the first frame to remove.
 * @param stop Index of the last frame to remove.
 * @return Void.
 */
*****

***** TOL_EDITOR\animation.cpp
}
/**
 * Serialize the Animation into a readable string for output to the .tan file.
 */
***** TOL_EDITOR_MASTER\animation.cpp
}

/**
 * Serializes the Animation into a string suitable for output in a .tan2 file.
 * @return A string object consisting of the tan file header information followed
 * by the formatted frames and their associated start times in milliseconds.
 */
*****

***** TOL_EDITOR\animation.cpp
            + std::to_string(recentColors[i].getBlue())
                        + " ");
                //add a new line halfway through
                if (i == (NUMCOLORS / 2) - 1)
                        recColors += "\n";
        }
***** TOL_EDITOR_MASTER\animation.cpp
            + std::to_string(recentColors[i].getBlue())
            + " ");
        }
*****

Comparing files TOL_EDITOR\animation.h and TOL_EDITOR_MASTER\animation.h
***** TOL_EDITOR\animation.h
/**
* CS 383
* Group #4
* Created: 11/05/2016
*
* This is the header file for the Animation class. This class is utilized to store
* the sequence of frames in the Tower of Light's animation as well as the header info
* for the resulting .tan2 file.
*/
***** TOL_EDITOR_MASTER\animation.h
/**
* @author Trevor Morse
* @date 11/05/2016
* @class Animation
* @brief This is the header file for the Animation class.
* @details This class is utilized to store the sequence of
* frames in the Tower of Light's animation as well as the header
* info for the resulting .tan2 file.
*
*/
*****

***** TOL_EDITOR\animation.h

/**
* Class for storing a list of frames and other information related to
* the overall animation.
*/
class Animation {
private:
        std::list<Frame> frames;
        std::string version;
        std::string filename;
    RGB lastColor;
    RGB recentColors[NUMCOLORS];
        int numFrames;
        int height;
        int width;

public:
***** TOL_EDITOR_MASTER\animation.h

class Animation {
public:
*****

***** TOL_EDITOR\animation.h
        std::string toString();
};
***** TOL_EDITOR_MASTER\animation.h
        std::string toString();

private:
    std::list<Frame> frames; //!< List containing the ordered sequence of frames.
    std::string version; //!< Version of the .tan2 file used for import/export.
    std::string filename; //!< Name of the .tan2 file to be exported.
    RGB lastColor; //!< The last color used while creating the animation.
    RGB recentColors[NUMCOLORS]; //!< The 16 Most recent colors used.
    int numFrames; //!< The total number of frames in the animation.
    int height; //!< The height in cell objects of each animation frame.
    int width; //!< The width in cell objects of each animation frame.
};
*****

Comparing files TOL_EDITOR\cell.cpp and TOL_EDITOR_MASTER\cell.cpp
***** TOL_EDITOR\cell.cpp
/**
 * CS 383
 * Group #4
 * Created: 11/05/2016
 *
 * This file contains the implimentation of the Cell class defined in cell.h
 */

***** TOL_EDITOR_MASTER\cell.cpp
/**
* @class Cell
*/

*****

***** TOL_EDITOR\cell.cpp
/**
 * Initialize a cell with the defualt color black
 */
***** TOL_EDITOR_MASTER\cell.cpp
/**
 * Initialize a cell with the defualt RGB object color
 * black.
 */
*****

***** TOL_EDITOR\cell.cpp
/**
 * Initialize a cell with an rgb structure
 * @param Color of the cell contained in an rgb struct
 */
***** TOL_EDITOR_MASTER\cell.cpp
/**
 * Initialize a cell with a pre-existing RGB object.
 * @param newColorValue An RGB object containing the
 * color to set the cell to.
 */
*****

***** TOL_EDITOR\cell.cpp
/**
 * Destructor empty for now
 */
***** TOL_EDITOR_MASTER\cell.cpp
/**
 * Default destructor, no memory to clean up so empty for
 * now.
 */
*****

***** TOL_EDITOR\cell.cpp
/**
 * Sets the color of the cell using an rgb struct
 * @param Color of the cell contained in an rgb struct
 */
***** TOL_EDITOR_MASTER\cell.cpp
/**
 * Sets the color of a cell using the color stored inside
 * an RGB object.
 * @param newColorValue An RGB object containing the
 * color to set the cell to.
 * @return Void.
 */
*****

***** TOL_EDITOR\cell.cpp
/**
 * Returns the color of this cell as an rgb struct
 */
***** TOL_EDITOR_MASTER\cell.cpp
/**
 * Returns a copy of the RGB object that contains
 * this cell's color.
 * @return An RGB object.
 */
*****

***** TOL_EDITOR\cell.cpp
/**
 * Serializes this class as a string suitable for output as part of a .tan file
 */
***** TOL_EDITOR_MASTER\cell.cpp
/**
 * Serializes this class by returing a string object
 * containing the RGB color as a 3 integer tuple.
 * @return A string containing 3 integers representing
 * red, green, blue in that order.
 */
*****

Comparing files TOL_EDITOR\cell.h and TOL_EDITOR_MASTER\cell.h
***** TOL_EDITOR\cell.h
/**
 * CS 383
 * Group #4
 * Created: 11/07/2016
 *
 * This file contains the method definitions for the Cell class.
 */

// This class handles the the cell data structure which holds
// the color value for a single cell within a frame.

***** TOL_EDITOR_MASTER\cell.h
/**
* @author Peter Fetros
* @date 11/07/2016
* @class Cell
* @brief This is the header file for the Cell class.
* @details This class handles the cell data such as color
* values related to the cells of an animations frames as well
* as the various functions and methods usd to set a cells color
* values
*/

*****

***** TOL_EDITOR\cell.h

/**
 * Class for storing RGB values for a single frame cell
 */
class Cell
***** TOL_EDITOR_MASTER\cell.h

class Cell
*****

***** TOL_EDITOR\cell.h
private:
    RGB colorValue;
};
***** TOL_EDITOR_MASTER\cell.h
private:
    RGB colorValue; //!< An RGB object used to contain the color data relevant to this cell
};
*****

Comparing files TOL_EDITOR\frame.cpp and TOL_EDITOR_MASTER\frame.cpp
***** TOL_EDITOR\frame.cpp
/**
 * CS 383
 * Group #4
 * Created: 11/07/2016
 *
 * This file contains the implimentation details of the Frame class defined in
 * frame.h
 */
#include "frame.h"
***** TOL_EDITOR_MASTER\frame.cpp
/**
* @class Frame
*/

#include "frame.h"
*****

***** TOL_EDITOR\frame.cpp
/**
 * initializes an empty Frame object.
 */
***** TOL_EDITOR_MASTER\frame.cpp
/**
 * Initializes an empty frame object with the default
 * values; FrameNumber: 0, and startTime = 0.
 */
*****

***** TOL_EDITOR\frame.cpp
/**
 * Initialize a frame with a specific width and height.
 * @param width of the frame (number of cells in a row)
 * @param height of the frame (number of rows in a frame)
 */
***** TOL_EDITOR_MASTER\frame.cpp
/**
 * Initialize a frame object by specifying the frames
 * width in cell objects followed by its height in cell objects.
 * @param width Width of the frame (number of cells in a row)
 * @param height Height of the frame (number of rows in a column)
 */
*****

***** TOL_EDITOR\frame.cpp
 * Initialize a frame as a copy of another frame
 * @param reference to a pre-exisitng frame
 */
***** TOL_EDITOR_MASTER\frame.cpp
 * Initialize a frame as a copy of another frame
 * @param newFrame Reference to a pre-exisitng frame
 */
*****

***** TOL_EDITOR\frame.cpp
/**
 * Placeholder for a destructor if needed in the future
 */
***** TOL_EDITOR_MASTER\frame.cpp
/**
 * Default destructor, no memory to clean up so empty for
 * now.
 */
*****

***** TOL_EDITOR\frame.cpp
/**
 * Set the color of a Cell at a x,y positon using seperate ints
 * for the red, green, blue values
 * @param Column position in the row of the frame
 * @param Row position in the frame
 * @param RGB class holding the color data for the cell
 */
***** TOL_EDITOR_MASTER\frame.cpp
/**
 * Set the color of a Cell at a position by passing in an
 * x and y coordinate along with an RGB object containing
 * the color to make the cell.
 * @param x Index of the selected row position in the frame.
 * @param y Index of the selected column position in the frame.
 * @param color RGB class holding the color data for the cell.
 * @return Void.
 */
*****

***** TOL_EDITOR\frame.cpp
/**
 * get the color of a cell using it's coordinates inside the frame
 * @param Column position in the row of the frame
 * @param Row position in the frame
 */
***** TOL_EDITOR_MASTER\frame.cpp
/**
 * get the color of a cell using it's x and y position inside the frame.
 * @param x Index of the selected row position in the frame.
 * @param y Index of the selected column position in the frame.
 * @return An RGB object containing the color of the specified cell.
 */
*****

***** TOL_EDITOR\frame.cpp
/**
 * get the number of a frame
 */
***** TOL_EDITOR_MASTER\frame.cpp
/**
 * Get the number representing the frames position in the
 * animation in relation to the first frame.
 * @return An integer representing this frames position.
 */
*****

***** TOL_EDITOR\frame.cpp
/**
 * set the number of a frame
 * @param Int representing frame number
 */
***** TOL_EDITOR_MASTER\frame.cpp
/**
 * Set the number representing the frames position in the
 * animation in relation to the first frame.
 * @param number An integer representing this frames position.
 * @return Void.
 */
*****

***** TOL_EDITOR\frame.cpp
/**
 * get the frame start time
 */
***** TOL_EDITOR_MASTER\frame.cpp
/**
 * Get the frame's start time in milliseconds.
 * @return An Integer representing the time to show this
 * frame during the animation, in milliseconds.
 */
*****

***** TOL_EDITOR\frame.cpp
/**
 * set the frame start time
 * @param Int representing the frame start time
 */
***** TOL_EDITOR_MASTER\frame.cpp
/**
 * Set the frame's start time in milliseconds.
 * @param time An Integer representing the time to show this
 * frame during the animation, in milliseconds.
 * @return Void.
 */
*****

***** TOL_EDITOR\frame.cpp
/**
 * Serialize the frame into string format suitable for tan file ouput.
 */
***** TOL_EDITOR_MASTER\frame.cpp
/**
 * Serialize the frame into a string object representing this
 * frame which is suitable for output into a .tan2 file
 * @return A string object starting with the startTime followed by
 * triples representing the color of every cell in the animation.
 */
*****

***** TOL_EDITOR\frame.cpp
{
    std::string frameString = "";
    
***** TOL_EDITOR_MASTER\frame.cpp
{
    std::string frameString = std::to_string(startTime);
    
*****

Comparing files TOL_EDITOR\frame.h and TOL_EDITOR_MASTER\frame.h
***** TOL_EDITOR\frame.h
/**
 * CS 383
 * Group #4
 * Created: 11/07/2016
 *
 * This file contains the method definitions for the Frame class.
 */

***** TOL_EDITOR_MASTER\frame.h
/**
* @author Peter Fetros
* @date 11/07/2016
* @class Frame
* @brief This is the header file for the Frame class.
* @details This class contains all of the information for a single
* frame of an animation. Objects of this class are comprised of a
* 2-Dimensional array of cell objects that make up the frames color parts.
* This class is also used to interact with the different cells, for example setting
* cell colors.
*/

*****

***** TOL_EDITOR\frame.h

/**
 * Class for storing all cells and represents a single
 * frame of the animation
 */
class Frame
***** TOL_EDITOR_MASTER\frame.h

class Frame
*****

***** TOL_EDITOR\frame.h
private:
    std::vector<std::vector<Cell>> cells;
    int frameNumber;
    int startTime;
};
***** TOL_EDITOR_MASTER\frame.h
private:
    std::vector<std::vector<Cell>> cells; //!< 2-Dimenstional Vector of cell objects making up the pixles of the frame
    int frameNumber; //!< This framse index location within the complete animation
    int startTime; //!< The time in milliseconds that this frame will be played during the Animation
};
*****

Comparing files TOL_EDITOR\input.cpp and TOL_EDITOR_MASTER\input.cpp
***** TOL_EDITOR\input.cpp
/**
 * CS 383
 * Group #4
 * Created 11/08/2016
 *
 * This file provides the function definitions for reading data in from a .tan file.
 */
#include "input.h"
***** TOL_EDITOR_MASTER\input.cpp
/**
* @name Input
*/

#include "input.h"
*****

***** TOL_EDITOR\input.cpp
 * Parse the specified string by spaces and store in a vector.
 * @param data string to be parsed
 */
***** TOL_EDITOR_MASTER\input.cpp
 * Parse the specified string by spaces and store in a vector.
 * @param data String object to be parsed
 * @return A STL Vector containing strings each comprised of a
 * single RGB value stored as a string
 */
*****

***** TOL_EDITOR\input.cpp
}
/**
***** TOL_EDITOR_MASTER\input.cpp
}

/**
*****

***** TOL_EDITOR\input.cpp
 * Use the specified data to set the RGB values of the Animation's last color.
 * @param data string with values
 * @param animation pointer to the Animation object
 */
***** TOL_EDITOR_MASTER\input.cpp
 * Use the specified data to set the RGB values of the Animation's last color.
 * @param data String object with RGB values.
 * @param animation A Pointer to an Animation object.
 */
*****

***** TOL_EDITOR\input.cpp
}
/**
***** TOL_EDITOR_MASTER\input.cpp
}

/**
*****

***** TOL_EDITOR\input.cpp
 * used colors in the Animation.
 * @param data string with the values
 * @param animation pointer to the Animation object
 */
***** TOL_EDITOR_MASTER\input.cpp
 * used colors in the Animation.
 * @param data String containing the RGB values.
 * @param animation A Pointer to an Animation object.
 * @return Void.
 */
*****

***** TOL_EDITOR\input.cpp
/**
 * Parse the config info from the specified data string.
 * @param data string with the info
 * @param animation pointer to the Animation object
 */
***** TOL_EDITOR_MASTER\input.cpp
/**
 * Parse a String containing the configuration info from the specified data string.
 * @param data String with the configuration info.
 * @param animation A pointer to an Animation object.
 * @return Void.
 */
*****

***** TOL_EDITOR\input.cpp
/**
 * Read in the Animation's header info from the specified file.
 * @param tanfile file reference
 * @param animation pointer to the Animation object
 */
***** TOL_EDITOR_MASTER\input.cpp
/**
 * Read in and parse the Animation's header info from the specified file.
 * @param tanfile A Reference to an ifstream object pointing
 * to the .tan2 file.
 * @param animation A Pointer to an Animation object.
 * @return Void.
 */
*****

***** TOL_EDITOR\input.cpp
        {
                version, file, lastColor, recentColors1, recentColors2, config
        };
***** TOL_EDITOR_MASTER\input.cpp
        {
        version, file, lastColor, recentColors, config
        };
*****

***** TOL_EDITOR\input.cpp
        int lineNum = 0;
        while (lineNum < 6 && std::getline(tanfile, line))
        {
***** TOL_EDITOR_MASTER\input.cpp
        int lineNum = 0;
    while (lineNum < 5 && std::getline(tanfile, line))
        {
*****

***** TOL_EDITOR\input.cpp
                        break;
                case recentColors1:
                        ///simply store the first line of recent colors to be handled once
                        ///the next line is read in
                        recColors = line + " ";
                        break;
                case recentColors2:
                        ///add on the second line of recent colors and then handle it all together
                        recColors += line;
                        handleRecentColors(recColors, animation);
                        break;
***** TOL_EDITOR_MASTER\input.cpp
                        break;
        case recentColors:
            handleRecentColors(line, animation);
                        break;
*****

***** TOL_EDITOR\input.cpp
/**
 * Parse the RGB values for a row of cells from the specified data and
 * set the corresponding cell colors in the frame.
 * @param rowNum index of the current row in the Frame
 * @param data string containing the cell values
 * @param frame pointer to frame
 * @param width of the frame
 */
void handleRowOfCells(int rowNum, std::string data, Frame *frame, int width) {
        std::vector<std::string> cellValues = tokenize(data);
    RGB tmp;
        //since the cell values are stored in RGB triples, there should be 3*width of the animation
    if (cellValues.size() == width*3) {
                int colNum = 0;
        for (int i = 0; i < cellValues.size(); i += 3) {
            tmp.setColor(std::stoi(cellValues[i]),
                         std::stoi(cellValues[i+1]),
                         std::stoi(cellValues[i+2]));
            frame->setCellColor(colNum++, rowNum, tmp);
                }
        }
        else {
                //throw error; will implement once ported into Qt framework
        }
}
***** TOL_EDITOR_MASTER\input.cpp
/**
 * Looks ahead in the file to the first line of cell values. Then tokenizes that line
 * to determine the number of values and divides that by 3 to account for the RGB triples
 * in order to find the number of cells in each row.
 * @note This function should only be called after reading the .tan2 file header and
 * just before reading in the frames.
 * @param tanfile A reference to an ifstream object pointing
 * to the .tan2 file.
 * @return {int} Width of the frames stored in the file.
 */
int getActualWidth(std::ifstream &tanfile) {
    if (tanfile.good()){
        //store the current position of the file for resetting later
        std::streampos startPos = tanfile.tellg();
        std::string line;
        //skip first line; it contains the frame's start time
        std::getline(tanfile,line);
        //this line contains the first row of cells
        std::getline(tanfile, line);
        std::vector<std::string> cells = tokenize(line);

        //reset the file position to where it was at the start of the call
        tanfile.seekg(startPos);

        //divide the size by 3 to account for the RGB triples
        return (int)(cells.size()/3);
    }
    return -1;
}
*****

***** TOL_EDITOR\input.cpp
/**
 * Read in the frames from the tanfile and store them in the Animation's list.
 * Note: this function picks up in the file where readHeader ended.
 * @param tanfile file containing the animation data
 * @param animation pointer to the Animation
 */
void readFrames(std::ifstream &tanfile, Animation *animation){
        std::string line;
        Frame frame(animation->getWidth(), animation->getHeight());
        std::list<Frame> frames;
        int pos = 0;
        while (std::getline(tanfile, line))
        {
                //the first line contains the time stamp
                frame.setStartTime(0 /*TODO: pass in converted time stamp once Frame class is fixed*/);
                //now read as many lines as are specified by the animation's height
                //each line corresponds to a row in the animation
                for (int i = 0; i < animation->getHeight(); i++)
                {
                        line = "";
                        std::getline(tanfile, line);
                        handleRowOfCells(i, line, &frame, animation->getWidth());
                }
                //now that all of the data has been collected for a single frame
                //handle that data and add it to the list of frames
                frame.setFrameNumber(pos++);
                frames.push_back(frame);
        }
        animation->setFrames(frames);
}
/**
 * Read in an Animation from the specified file.
 * @param filename
 */
Animation readInAnimation(const char *filename) {
        Animation animation;

        std::ifstream tanfile;
        tanfile.open(filename);
        readHeader(tanfile, &animation);
        readFrames(tanfile, &animation);
        tanfile.close();

        return animation;
}
***** TOL_EDITOR_MASTER\input.cpp
/**
 * Looks ahead in the file to determine the actual height of the frame in a .tan2  file. Then
 * counts the number of rows before the line containing the next frame's start time in order
 * to determine the number of rows in a column.
 * @note This function should only be called after reading the .tan2  file header and
 * just before reading in the frames.
 * @param tanfile A reference to an ifstream object pointing
 * to the .tan2 file.
 * @return Integer value representing the number of rows in a .tan2 file
 */
int getActualHeight(std::ifstream &tanfile){
    if (tanfile.good()){
        //store the current position of the file for resetting later
        std::streampos startPos = tanfile.tellg();
        std::string line;
        int actualHeight = 0;

        //skip first line; it contains the frame's start time
        std::getline(tanfile, line);
        //this next line is the first row of cells in the frame; start with it
        std::getline(tanfile, line);
        //If the tokenized line contains more than one item, then it is another
        //row of cells and should be counted into the frame's actualHeight.
        //If the tokenized line only contains less than one item, then it is the start time
        //for the next frame or the end of file and the count should be stopped.
        while(tokenize(line).size() > 1){
            actualHeight++;
            std::getline(tanfile, line);
        }

        //if the animation file only had one frame, then it will have reached the eof
        //if so, clear the eof bit and set it back to the original position from the start of the file
        if(tanfile.eof()){
            tanfile.clear();
            tanfile.seekg(startPos, std::ios_base::beg);
        }
        //if not, simply reset to the original position
        else
            tanfile.seekg(startPos);

        return actualHeight;
    }
    return -1;
}
*****

***** TOL_EDITOR\input.cpp
***** TOL_EDITOR_MASTER\input.cpp

/**
 * Parse the RGB values for a row of cells from the specified data and
 * set the corresponding cell colors in the frame.
 * @param rowNum Index of the current row in the Frame.
 * @param data String object containing the cell values.
 * @param frame A Pointer to a frame object.
 * @param width Width of the frame in cell objects.
 * @return Void.
 */
void handleRowOfCells(int rowNum, std::string data, Frame *frame, int width) {
        std::vector<std::string> cellValues = tokenize(data);
    RGB tmp;
        //since the cell values are stored in RGB triples, there should be 3*width of the animation
    if (cellValues.size() == width*3) {
                int colNum = 0;
        for (int i = 0; i < cellValues.size(); i += 3) {
            tmp.setColor(std::stoi(cellValues[i]),
                         std::stoi(cellValues[i+1]),
                         std::stoi(cellValues[i+2]));
            frame->setCellColor(colNum++, rowNum, tmp);
                }
        }
        else {
                //throw error; will implement once ported into Qt framework
        }
}
/**
 * Read in the frames from the tanfile and store them in the Animation's list.
 * @note This function picks up in the file where readHeader ended.
 * @note Due to the pre-existing format of the .tan2 file and its
     * storage of the incorrect height and width of a frame in its config info,
     * it is necessary to programmatically determine those values through reading the file.
     * This is relatively costly since it involves multiple file I/O operations, but is necessary
     * in order to be backwards-compatible with existing infrastructure.
 * @param tanfile A Reference to an ifstream object pointing
 * to the .tan2 file.
 * @param animation A Pointer to the Animation
 */
void readFrames(std::ifstream &tanfile, Animation *animation){
    /*
     * Note: Due to the pre-existing format of the .tan2 file and its
     * storage of the incorrect height and width of a frame in its config info,
     * it is necessary to programmatically determine those values through reading the file.
     * This is relatively costly since it involves multiple file I/O operations, but is necessary
     * in order to be backwards-compatible with existing infrastructure.
     */
    animation->setWidth(getActualWidth(tanfile));
    animation->setHeight(getActualHeight(tanfile));
    Frame frame(animation->getWidth(), animation->getHeight());

    std::string line;
        std::list<Frame> frames;
        int pos = 0;
        while (std::getline(tanfile, line))
        {
                //the first line contains the time stamp
        frame.setStartTime(std::stoi(line));
                //now read as many lines as are specified by the animation's height
                //each line corresponds to a row in the animation
                for (int i = 0; i < animation->getHeight(); i++)
                {
                        line = "";
                        std::getline(tanfile, line);
                        handleRowOfCells(i, line, &frame, animation->getWidth());
                }
                //now that all of the data has been collected for a single frame
                //handle that data and add it to the list of frames
                frame.setFrameNumber(pos++);
                frames.push_back(frame);
        }
        animation->setFrames(frames);
}
/**
 * Read in an Animation from the specified file location/name.
 * @param a filename or filepath to read from.
 * @return An Animation object containing the animation.
 */
Animation readInAnimation(const char *filename) {
        Animation animation;

        std::ifstream tanfile;
        tanfile.open(filename);
    if (tanfile.good()){
        readHeader(tanfile, &animation);
        readFrames(tanfile, &animation);
    }
        tanfile.close();

        return animation;
}
*****

Comparing files TOL_EDITOR\input.h and TOL_EDITOR_MASTER\input.h
***** TOL_EDITOR\input.h
/**
* CS 383
* Group #4
* Created 11/09/2016
*
* This file provides the function stubs for reading data in from a .tan file.
*/
***** TOL_EDITOR_MASTER\input.h
/**
* @author Trevor Morse
* @date 11/09/2016
* @name Input
* @brief This is the header file that defines the file reading functionality.
* @details This header file defines the different functions that are used
* during the process of reading an animations .tan2 file into the Tower Lights
* animator and then extracting the information and translating it into the proper
* data structures and objects
*/
*****

***** TOL_EDITOR\input.h
void readHeader(std::ifstream &tanfile, Animation *animation);
void handleRowOfCells(int rowNum, std::string data, Frame *frame, int width);
***** TOL_EDITOR_MASTER\input.h
void readHeader(std::ifstream &tanfile, Animation *animation);
int getActualWidth(std::ifstream &tanfile);
int getActualHeight(std::ifstream &tanfile);
void handleRowOfCells(int rowNum, std::string data, Frame *frame, int width);
*****

Comparing files TOL_EDITOR\main.cpp and TOL_EDITOR_MASTER\main.cpp
***** TOL_EDITOR\main.cpp

int main(int argc, char *argv[])
***** TOL_EDITOR_MASTER\main.cpp

/**
 * Initial point of execution for the program. Yhis function
 * will initialyze the Qt window for the Tower Lights Animator and
 * also Initialize any data structures necessary for it's function.
 * @param argc An Integer representing the number of arguments
 * passed into the application.
 * @param argv A Pointer to a character array that contains the
 * arguments passed into the application.
 * @return An Integer representing the exit status of the program
 * once it ends its execution.
 */
int main(int argc, char *argv[])
*****

***** TOL_EDITOR\main.cpp
    Toolbox t;
    t.setupUi(toolboxParent);

***** TOL_EDITOR_MASTER\main.cpp
    Toolbox t;
    t.setupUiTotal(toolboxParent);

*****

Comparing files TOL_EDITOR\mainwindow.cpp and TOL_EDITOR_MASTER\mainwindow.cpp
***** TOL_EDITOR\mainwindow.cpp
#include "mainwindow.h"
#include "ui_mainwindow.h"
***** TOL_EDITOR_MASTER\mainwindow.cpp
/**
* @class MainWindow
*/

#include "mainwindow.h"
#include "ui_mainwindow.h"
*****

Comparing files TOL_EDITOR\mainwindow.h and TOL_EDITOR_MASTER\mainwindow.h
***** TOL_EDITOR\mainwindow.h
#ifndef MAINWINDOW_H
#define MAINWINDOW_H
***** TOL_EDITOR_MASTER\mainwindow.h
/**
* @author ...
* @date 11/20/2016
* @class MainWindow
* @brief This is the header file defining the MainWindow Class
* @details This header file defines the MainWindow class which is object in
* the Tower Lights Animator that contains all of the different User Interface
* functionality as well as the different objects that make up the animation itself.
*/

#ifndef MAINWINDOW_H
#define MAINWINDOW_H
*****

***** TOL_EDITOR\mainwindow.h
private:
    Ui::MainWindow *ui;
};
***** TOL_EDITOR_MASTER\mainwindow.h
private:
    Ui::MainWindow *ui; //!< Reference to the internal UI object
};
*****

Comparing files TOL_EDITOR\mainwindow.ui and TOL_EDITOR_MASTER\mainwindow.ui
FC: no differences encountered

Comparing files TOL_EDITOR\outputfile.cpp and TOL_EDITOR_MASTER\outputfile.cpp
***** TOL_EDITOR\outputfile.cpp
/**
 * CS 383
 * Group #4
 * Created: 11/08/2016
 *
 * This file contains the methods for writing out a .tan file
 */

***** TOL_EDITOR_MASTER\outputfile.cpp
/**
* @name Output
*/

*****

***** TOL_EDITOR\outputfile.cpp
/**
 * Check the filename for extenstion and add it if not present
 * @param The raw file name string passed into writefile
 */
***** TOL_EDITOR_MASTER\outputfile.cpp
/**
 * Check the filename for extenstion and add it if not present.
 * @param rawFileName The raw file name string passed into writefile.
 * @return A string object containing the properly formatted filepath, including file extension.
 */
*****

***** TOL_EDITOR\outputfile.cpp
    std::transform(lowerName.begin(), lowerName.end(), lowerName.begin(), ::tolower);
    
    if (lowerName.find(".tan",lowerName.size()-4) == std::string::npos)
        return (rawFileName + ".tan");
    else
***** TOL_EDITOR_MASTER\outputfile.cpp
    std::transform(lowerName.begin(), lowerName.end(), lowerName.begin(), ::tolower);
    std::string fileType = ".tan2";
    if (lowerName.find(fileType,lowerName.size()-fileType.size()) == std::string::npos)
        return (rawFileName + ".tan2");
    else
*****

***** TOL_EDITOR\outputfile.cpp
 * Write the animation to a specified file location.
 * @param The file name or path where the file should be written
 * @param animation pointer to the Animation object
 */
***** TOL_EDITOR_MASTER\outputfile.cpp
 * Write the animation to a specified file location.
 * @param rawFileName The file name or path where the file should be written
 * @param animation A pointer to the Animation object
 */
*****

***** TOL_EDITOR\outputfile.cpp
 * returns a string representation of the error, if it exists,
 * returned by the writeFile function
 * @param Integer Error number returned by the writeFile function
 */
***** TOL_EDITOR_MASTER\outputfile.cpp
 * returns a string representation of the error, if it exists,
 * returned by the writeFile function.
 * @param errorCode An Integer representing the error number returned by the writeFile function.
 * @return A string object containing a description of the error that occured.
 */
*****

Comparing files TOL_EDITOR\outputfile.h and TOL_EDITOR_MASTER\outputfile.h
***** TOL_EDITOR\outputfile.h
/**
 * CS 383
 * Group #4
 * Created: 11/08/2016
 *
 * This file defines the function defintions for outputting a tan file
 */

***** TOL_EDITOR_MASTER\outputfile.h
/**
* @author Peter Fetros
* @date 11/08/2016
* @name Input
* @brief This is the header file that defines the file output functionality.
* @details This header file defines the different functions that are used
* during the process of writing an animations into a .tan2 file. It also defines
* several helper functions that are used for determinding proper filename and paths
* as well a function for getting a string representation of any errors returned by the
* file writing process.
*/

*****

***** TOL_EDITOR\outputfile.h

/**
 * Header for functions relating to writing out  tan file
 */

int writeFile(std::string rawFileName, Animation* animation);
***** TOL_EDITOR_MASTER\outputfile.h

int writeFile(std::string rawFileName, Animation* animation);
*****

Comparing files TOL_EDITOR\RGB.cpp and TOL_EDITOR_MASTER\RGB.cpp
***** TOL_EDITOR\RGB.cpp
/**
 * CS 383
 * Group #4
 * Created: 11/12/2016
 *
 * This file contains the implimentations of the RGB class used
 * to hold Red Green Blue values.
 */

***** TOL_EDITOR_MASTER\RGB.cpp
/**
* @class RGB
*/

*****

***** TOL_EDITOR\RGB.cpp
/**
 * Default constructor initializes color to black
 */
***** TOL_EDITOR_MASTER\RGB.cpp
/**
 * Default constructor initializing all color components
 * to the default value of 0.
 */
*****

***** TOL_EDITOR\RGB.cpp
/**
 * constructor that initializes color to passed in values
 * @param integer value representing amount of red
 * @param integer value representing amount of green
 * @param integer value representing amount of blue
 */
***** TOL_EDITOR_MASTER\RGB.cpp
/**
 * constructor that initializes the RGB object to the
 * color component values passed in to the constructor.
 * @param red Integer value representing amount of red.
 * @param green Integer value representing amount of green.
 * @param blue Integer value representing amount of blue.
 */
*****

***** TOL_EDITOR\RGB.cpp
/**
 * constructor that initializes color to a html hex value
 * @param a string value representing a 6 bit hexidecimal value
 */
***** TOL_EDITOR_MASTER\RGB.cpp
/**
 * constructor that initializes the RGB object to the
 * color to the color passed in after converting it from HTNL Hex to
 * RGB
 * @param hex A string object representing a 6 bit hexidecimal value
 */
*****

***** TOL_EDITOR\RGB.cpp
/**
 * constructor that converts Hue Saturation Lightness to RGB and creates object
 * @param an integer representing an angle of hue between 0 and 360
***** TOL_EDITOR_MASTER\RGB.cpp
/**
 * constructor that initializes the RGB object to the
 * color passed in after converting it from HSL (Hue Saturation
 * Lightness) to RGB color format.
 * @param an integer representing an angle of hue between 0 and 360
*****

Comparing files TOL_EDITOR\RGB.h and TOL_EDITOR_MASTER\RGB.h
***** TOL_EDITOR\RGB.h
/**
 * CS 383
 * Group #4
 * Created: 11/12/2016
 *
 * This file contains the definitions of RGB class used
 * to hold Red Green Blue values.
 */

***** TOL_EDITOR_MASTER\RGB.h
/**
* @author Peter Fetros
* @date 11/12/2016
* @class RGB
* @brief This is the header file that defines the RGB class.
* @details This header file defines the class used to contain the color data
* used by the cells to determine what color they will be during an animation.
* It also contains several methods for converting different color representations
* into the RGB color format.
*/

*****

***** TOL_EDITOR\RGB.h
private:
    int red;
    int green;
    int blue;
    
***** TOL_EDITOR_MASTER\RGB.h
private:
    int red; //!< An integer between 0 and 255 representing the red component of the color
    int green; //!< An integer between 0 and 255 representing the green component of the color
    int blue; //!< An integer between 0 and 255 representing the blue component of the color
    
*****

Comparing files TOL_EDITOR\tol_editor.pro and TOL_EDITOR_MASTER\tol_editor.pro
FC: no differences encountered

Comparing files TOL_EDITOR\tol_editor.pro.user and TOL_EDITOR_MASTER\tol_editor.pro.user
***** TOL_EDITOR\tol_editor.pro.user
<!DOCTYPE QtCreatorProject>
<!-- Written by QtCreator 4.1.0, 2016-11-22T13:48:56. -->
<qtcreator>
***** TOL_EDITOR_MASTER\tol_editor.pro.user
<!DOCTYPE QtCreatorProject>
<!-- Written by QtCreator 4.1.0, 2016-11-22T13:34:03. -->
<qtcreator>
*****

***** TOL_EDITOR\tol_editor.pro.user
    <value type="QString" key="ProjectExplorer.ProjectConfiguration.DefaultDisplayName">tol_editor</value>
    <value type="QString" key="ProjectExplorer.ProjectConfiguration.DisplayName"></value>
    <value type="QString" key="ProjectExplorer.ProjectConfiguration.Id">Qt4ProjectManager.Qt4RunConfiguration:C:/Users/matthew/
Documents/GitHub/towerLights/tol/tol_editor/tol_editor.pro</value>
    <value type="bool" key="QmakeProjectManager.QmakeRunConfiguration.UseLibrarySearchPath">true</value>
***** TOL_EDITOR_MASTER\tol_editor.pro.user
    <value type="QString" key="ProjectExplorer.ProjectConfiguration.DefaultDisplayName">tol_editor</value>
    <value type="QString" key="ProjectExplorer.ProjectConfiguration.DisplayName">tol_editor2</value>
    <value type="QString" key="ProjectExplorer.ProjectConfiguration.Id">Qt4ProjectManager.Qt4RunConfiguration:C:/Users/matthew/
Desktop/tol_editor/tol_editor.pro</value>
    <value type="bool" key="QmakeProjectManager.QmakeRunConfiguration.UseLibrarySearchPath">true</value>
*****

Comparing files TOL_EDITOR\toolbox.cpp and TOL_EDITOR_MASTER\toolbox.cpp
***** TOL_EDITOR\toolbox.cpp
{
    if (Toolbox->objectName().isEmpty()){
        Toolbox->setObjectName(QStringLiteral("Toolbox"));
    }

    Toolbox->resize(530, 635);

    setupUiTabs(Toolbox);

    setupUiMasterWidget();

    setupUiLabels(widget);

    setupUiWidgets(widget);

    setupUiLayouts(widget);

    setupUiColorDialogue();

    retranslateUi(Toolbox);

    QMetaObject::connectSlotsByName(Toolbox);
} // setupUi

void Toolbox::setupUiTabs(QWidget *Toolbox){
    tabWidget = new QTabWidget(Toolbox);
***** TOL_EDITOR_MASTER\toolbox.cpp
{
    if (Toolbox->objectName().isEmpty())
        Toolbox->setObjectName(QStringLiteral("Toolbox"));
    Toolbox->resize(530, 635);
    tabWidget = new QTabWidget(Toolbox);
*****

***** TOL_EDITOR\toolbox.cpp
    tabWidget->setObjectName(QStringLiteral("tabWidget"));
    tabWidget->setGeometry(QRect(10, 10, 511, 621));
    tabWidget->setAutoFillBackground(false);

    tab = new QWidget();
***** TOL_EDITOR_MASTER\toolbox.cpp
    tabWidget->setObjectName(QStringLiteral("tabWidget"));
    tabWidget->setGeometry(QRect(0, 10, 521, 611));
    tabWidget->setAutoFillBackground(false);
    tab = new QWidget();
*****

***** TOL_EDITOR\toolbox.cpp
    tabWidget->addTab(tab, QString());

    tab_2 = new QWidget();
***** TOL_EDITOR_MASTER\toolbox.cpp
    tabWidget->addTab(tab, QString());
    tab_2 = new QWidget();
*****

***** TOL_EDITOR\toolbox.cpp
    tab_2->setObjectName(QStringLiteral("tab_2"));
    tabWidget->addTab(tab_2, QString());
}

void Toolbox::setupUiMasterWidget(){
    widget = new QWidget(tab_2);
    widget->setObjectName(QStringLiteral("widget"));
    widget->setGeometry(QRect(9, 9, 481, 581));
}

void Toolbox::setupUiLabels(QWidget *widget)
{
    label = new QLabel(widget);
    label->setObjectName(QStringLiteral("label"));

    label_6 = new QLabel(widget);
    label_6->setObjectName(QStringLiteral("label_6"));

    label_2 = new QLabel(widget);
    label_2->setObjectName(QStringLiteral("label_2"));

    label_5 = new QLabel(widget);
    label_5->setObjectName(QStringLiteral("label_5"));

    label_9 = new QLabel(widget);
    label_9->setObjectName(QStringLiteral("label_9"));

    label_10 = new QLabel(widget);
    label_10->setObjectName(QStringLiteral("label_10"));

    label_7 = new QLabel(widget);
    label_7->setObjectName(QStringLiteral("label_7"));

    label_11 = new QLabel(widget);
    label_11->setObjectName(QStringLiteral("label_11"));

    label_4 = new QLabel(widget);
    label_4->setObjectName(QStringLiteral("label_4"));

    label_17 = new QLabel(widget);
    label_17->setObjectName(QStringLiteral("label_17"));

    label_12 = new QLabel(widget);
    label_12->setObjectName(QStringLiteral("label_12"));

    label_3 = new QLabel(widget);
    label_3->setObjectName(QStringLiteral("label_3"));

    label_13 = new QLabel(widget);
    label_13->setObjectName(QStringLiteral("label_13"));

    label_8 = new QLabel(widget);
    label_8->setObjectName(QStringLiteral("label_8"));

    label_14 = new QLabel(widget);
    label_14->setObjectName(QStringLiteral("label_14"));

    label_15 = new QLabel(widget);
    label_15->setObjectName(QStringLiteral("label_15"));

    label_23 = new QLabel(widget);
    label_23->setObjectName(QStringLiteral("label_23"));

    label_21 = new QLabel(widget);
    label_21->setObjectName(QStringLiteral("label_21"));

    label_19 = new QLabel(widget);
    label_19->setObjectName(QStringLiteral("label_19"));

    label_16 = new QLabel(widget);
    label_16->setObjectName(QStringLiteral("label_16"));

    label_24 = new QLabel(widget);
    label_24->setObjectName(QStringLiteral("label_24"));

    label_22 = new QLabel(widget);
    label_22->setObjectName(QStringLiteral("label_22"));

    label_20 = new QLabel(widget);
    label_20->setObjectName(QStringLiteral("label_20"));

    label_18 = new QLabel(widget);
    label_18->setObjectName(QStringLiteral("label_18"));
}

void Toolbox::setupUiWidgets(QWidget *widget)
{
    addFramesStart = new QSpinBox(widget);
    addFramesStart->setObjectName(QStringLiteral("addFramesStart"));
***** TOL_EDITOR_MASTER\toolbox.cpp
    tab_2->setObjectName(QStringLiteral("tab_2"));
    gridLayout_3 = new QGridLayout(tab_2);
    gridLayout_3->setSpacing(6);
    gridLayout_3->setContentsMargins(11, 11, 11, 11);
    gridLayout_3->setObjectName(QStringLiteral("gridLayout_3"));
    horizontalLayout_5 = new QHBoxLayout();
    horizontalLayout_5->setSpacing(6);
    horizontalLayout_5->setObjectName(QStringLiteral("horizontalLayout_5"));
    addFramesStart = new QSpinBox(tab_2);
    addFramesStart->setObjectName(QStringLiteral("addFramesStart"));
*****

***** TOL_EDITOR\toolbox.cpp

    addFramesEnd = new QSpinBox(widget);
    addFramesEnd->setObjectName(QStringLiteral("addFramesEnd"));
***** TOL_EDITOR_MASTER\toolbox.cpp

    horizontalLayout_5->addWidget(addFramesStart);

    addFramesEnd = new QSpinBox(tab_2);
    addFramesEnd->setObjectName(QStringLiteral("addFramesEnd"));
*****

***** TOL_EDITOR\toolbox.cpp

    addFramesButton = new QPushButton(widget);
    addFramesButton->setObjectName(QStringLiteral("addFramesButton"));
***** TOL_EDITOR_MASTER\toolbox.cpp

    horizontalLayout_5->addWidget(addFramesEnd);

    addFramesButton = new QPushButton(tab_2);
    addFramesButton->setObjectName(QStringLiteral("addFramesButton"));
*****

***** TOL_EDITOR\toolbox.cpp

    removeFramesStart = new QSpinBox(widget);
    removeFramesStart->setObjectName(QStringLiteral("removeFramesStart"));

    removeFramesEnd = new QSpinBox(widget);
    removeFramesEnd->setObjectName(QStringLiteral("removeFramesEnd"));

    removeFramesButton = new QPushButton(widget);
    removeFramesButton->setObjectName(QStringLiteral("removeFramesButton"));

    copyFramesIndex = new QSpinBox(widget);
    copyFramesIndex->setObjectName(QStringLiteral("copyFramesIndex"));

    copyFramesStart = new QSpinBox(widget);
    copyFramesStart->setObjectName(QStringLiteral("copyFramesStart"));
***** TOL_EDITOR_MASTER\toolbox.cpp

    horizontalLayout_5->addWidget(addFramesButton);


    gridLayout_3->addLayout(horizontalLayout_5, 0, 0, 1, 1);

    horizontalLayout_3 = new QHBoxLayout();
    horizontalLayout_3->setSpacing(6);
    horizontalLayout_3->setObjectName(QStringLiteral("horizontalLayout_3"));
    horizontalLayout_2 = new QHBoxLayout();
    horizontalLayout_2->setSpacing(6);
    horizontalLayout_2->setObjectName(QStringLiteral("horizontalLayout_2"));
    copyFramesStart = new QSpinBox(tab_2);
    copyFramesStart->setObjectName(QStringLiteral("copyFramesStart"));
*****

***** TOL_EDITOR\toolbox.cpp

    copyFramesEnd = new QSpinBox(widget);
    copyFramesEnd->setObjectName(QStringLiteral("copyFramesEnd"));
***** TOL_EDITOR_MASTER\toolbox.cpp

    horizontalLayout_2->addWidget(copyFramesStart);

    copyFramesEnd = new QSpinBox(tab_2);
    copyFramesEnd->setObjectName(QStringLiteral("copyFramesEnd"));
*****

***** TOL_EDITOR\toolbox.cpp

    copyFramesButton = new QPushButton(widget);
    copyFramesButton->setObjectName(QStringLiteral("copyFramesButton"));
***** TOL_EDITOR_MASTER\toolbox.cpp

    horizontalLayout_2->addWidget(copyFramesEnd);


    horizontalLayout_3->addLayout(horizontalLayout_2);

    horizontalLayout = new QHBoxLayout();
    horizontalLayout->setSpacing(6);
    horizontalLayout->setObjectName(QStringLiteral("horizontalLayout"));
    copyFramesIndex = new QSpinBox(tab_2);
    copyFramesIndex->setObjectName(QStringLiteral("copyFramesIndex"));

    horizontalLayout->addWidget(copyFramesIndex);

    copyFramesButton = new QPushButton(tab_2);
    copyFramesButton->setObjectName(QStringLiteral("copyFramesButton"));
*****

***** TOL_EDITOR\toolbox.cpp

    currentTime = new QTimeEdit(widget);
    currentTime->setObjectName(QStringLiteral("currentTime"));

    timeInterval = new QTimeEdit(widget);
    timeInterval->setObjectName(QStringLiteral("timeInterval"));
    timeInterval->setTimeSpec(Qt::LocalTime);
}
***** TOL_EDITOR_MASTER\toolbox.cpp

    horizontalLayout->addWidget(copyFramesButton);


    horizontalLayout_3->addLayout(horizontalLayout);


    gridLayout_3->addLayout(horizontalLayout_3, 2, 0, 1, 1);

    horizontalLayout_4 = new QHBoxLayout();
    horizontalLayout_4->setSpacing(6);
    horizontalLayout_4->setObjectName(QStringLiteral("horizontalLayout_4"));
    removeFramesStart = new QSpinBox(tab_2);
    removeFramesStart->setObjectName(QStringLiteral("removeFramesStart"));

    horizontalLayout_4->addWidget(removeFramesStart);

    removeFramesEnd = new QSpinBox(tab_2);
    removeFramesEnd->setObjectName(QStringLiteral("removeFramesEnd"));

    horizontalLayout_4->addWidget(removeFramesEnd);

    removeFramesButton = new QPushButton(tab_2);
    removeFramesButton->setObjectName(QStringLiteral("removeFramesButton"));

    horizontalLayout_4->addWidget(removeFramesButton);


    gridLayout_3->addLayout(horizontalLayout_4, 1, 0, 1, 1);

    tabWidget->addTab(tab_2, QString());

    retranslateUi(Toolbox);

    tabWidget->setCurrentIndex(1);

    dialog = new QColorDialog(this->tab);
    dialog->setWindowFlags(Qt::SubWindow);
    dialog->setOptions(QColorDialog::DontUseNativeDialog | QColorDialog::NoButtons);
    dialog->move(0,50);
    //QObject::connect(dialog, SIGNAL(currentColorChanged(QColor)), Toolbox, SLOT(colorChanged()));
    QMetaObject::connectSlotsByName(Toolbox);
} // setupUi

/**
 * Function to retranslate the user interface
 */
void Toolbox::retranslateUi(QWidget *Toolbox)
{
    Toolbox->setWindowTitle(QApplication::translate("Toolbox", "Toolbox", 0));
    tabWidget->setTabText(tabWidget->indexOf(tab), QApplication::translate("Toolbox", "Color", 0));
    addFramesButton->setText(QApplication::translate("Toolbox", "Add Frames", 0));
    copyFramesButton->setText(QApplication::translate("Toolbox", "Copy Frames", 0));
    removeFramesButton->setText(QApplication::translate("Toolbox", "Remove Frames", 0));
    tabWidget->setTabText(tabWidget->indexOf(tab_2), QApplication::translate("Toolbox", "Editing", 0));
} // retranslateUi

/**
 * Signal Function Stubs
 */
void Toolbox::on_addFramesEnd_valueChanged(int arg1)
{

}
*****

***** TOL_EDITOR\toolbox.cpp

void Toolbox::setupUiLayouts(QWidget *widget)
{
    verticalLayout_10 = new QVBoxLayout(widget);
    verticalLayout_10->setSpacing(6);
    verticalLayout_10->setContentsMargins(11, 11, 11, 11);
    verticalLayout_10->setObjectName(QStringLiteral("verticalLayout_10"));
    verticalLayout_10->setContentsMargins(0, 0, 0, 0);
    horizontalLayout = new QHBoxLayout();
    horizontalLayout->setSpacing(6);
    horizontalLayout->setObjectName(QStringLiteral("horizontalLayout"));
    verticalLayout = new QVBoxLayout();
    verticalLayout->setSpacing(6);
    verticalLayout->setObjectName(QStringLiteral("verticalLayout"));
    verticalLayout->addWidget(label);
    verticalLayout->addWidget(addFramesStart);
    verticalLayout->addWidget(label_6);
    horizontalLayout->addLayout(verticalLayout);
    verticalLayout_2 = new QVBoxLayout();
    verticalLayout_2->setSpacing(6);
    verticalLayout_2->setObjectName(QStringLiteral("verticalLayout_2"));
    verticalLayout_2->addWidget(label_2);
    verticalLayout_2->addWidget(addFramesEnd);
    verticalLayout_2->addWidget(label_5);
    horizontalLayout->addLayout(verticalLayout_2);
    horizontalLayout->addWidget(addFramesButton);
    verticalLayout_10->addLayout(horizontalLayout);
    horizontalLayout_2 = new QHBoxLayout();
    horizontalLayout_2->setSpacing(6);
    horizontalLayout_2->setObjectName(QStringLiteral("horizontalLayout_2"));
    verticalLayout_3 = new QVBoxLayout();
    verticalLayout_3->setSpacing(6);
    verticalLayout_3->setObjectName(QStringLiteral("verticalLayout_3"));
    verticalLayout_3->addWidget(label_9);
    verticalLayout_3->addWidget(removeFramesStart);
    verticalLayout_3->addWidget(label_10);
    horizontalLayout_2->addLayout(verticalLayout_3);
    verticalLayout_4 = new QVBoxLayout();
    verticalLayout_4->setSpacing(6);
    verticalLayout_4->setObjectName(QStringLiteral("verticalLayout_4"));
    verticalLayout_4->addWidget(label_7);
    verticalLayout_4->addWidget(removeFramesEnd);
    verticalLayout_4->addWidget(label_11);
    horizontalLayout_2->addLayout(verticalLayout_4);
    horizontalLayout_2->addWidget(removeFramesButton);
    verticalLayout_10->addLayout(horizontalLayout_2);
    horizontalLayout_3 = new QHBoxLayout();
    horizontalLayout_3->setSpacing(6);
    horizontalLayout_3->setObjectName(QStringLiteral("horizontalLayout_3"));
    verticalLayout_5 = new QVBoxLayout();
    verticalLayout_5->setSpacing(6);
    verticalLayout_5->setObjectName(QStringLiteral("verticalLayout_5"));
    verticalLayout_5->addWidget(label_4);
    verticalLayout_5->addWidget(copyFramesIndex);
    verticalLayout_5->addWidget(label_12);
    horizontalLayout_3->addLayout(verticalLayout_5);
    verticalLayout_6 = new QVBoxLayout();
    verticalLayout_6->setSpacing(6);
    verticalLayout_6->setObjectName(QStringLiteral("verticalLayout_6"));
    verticalLayout_6->addWidget(label_3);
    verticalLayout_6->addWidget(copyFramesStart);
    verticalLayout_6->addWidget(label_13);
    horizontalLayout_3->addLayout(verticalLayout_6);
    verticalLayout_7 = new QVBoxLayout();
    verticalLayout_7->setSpacing(6);
    verticalLayout_7->setObjectName(QStringLiteral("verticalLayout_7"));
    verticalLayout_7->addWidget(label_8);
    verticalLayout_7->addWidget(copyFramesEnd);
    verticalLayout_7->addWidget(label_14);
    horizontalLayout_3->addLayout(verticalLayout_7);
    horizontalLayout_3->addWidget(copyFramesButton);
    verticalLayout_10->addLayout(horizontalLayout_3);
    horizontalLayout_4 = new QHBoxLayout();
    horizontalLayout_4->setSpacing(6);
    horizontalLayout_4->setObjectName(QStringLiteral("horizontalLayout_4"));
    verticalLayout_8 = new QVBoxLayout();
    verticalLayout_8->setSpacing(6);
    verticalLayout_8->setObjectName(QStringLiteral("verticalLayout_8"));
    verticalLayout_8->addWidget(label_15);
    verticalLayout_8->addWidget(currentTime);
    verticalLayout_8->addWidget(label_23);
    verticalLayout_8->addWidget(label_21);
    verticalLayout_8->addWidget(label_19);
    verticalLayout_8->addWidget(label_17);
    horizontalLayout_4->addLayout(verticalLayout_8);
    verticalLayout_9 = new QVBoxLayout();
    verticalLayout_9->setSpacing(6);
    verticalLayout_9->setObjectName(QStringLiteral("verticalLayout_9"));
    verticalLayout_9->addWidget(label_16);
    verticalLayout_9->addWidget(timeInterval);
    verticalLayout_9->addWidget(label_24);
    verticalLayout_9->addWidget(label_22);
    verticalLayout_9->addWidget(label_20);
    verticalLayout_9->addWidget(label_18);
    horizontalLayout_4->addLayout(verticalLayout_9);
    verticalLayout_10->addLayout(horizontalLayout_4);
}
***** TOL_EDITOR_MASTER\toolbox.cpp

void Toolbox::on_addFramesStart_valueChanged(int arg1)
{

}

void Toolbox::on_addFramesButton_clicked()
{

}

void Toolbox::on_removeFramesStart_valueChanged(int arg1)
{

}

void Toolbox::on_removeFramesEnd_valueChanged(int arg1)
{

}

void Toolbox::on_removeFramesButton_clicked()
{

}

void Toolbox::on_copyFramesStart_valueChanged(int arg1)
{

}

void Toolbox::on_copyFramesEnd_valueChanged(int arg1)
{

}

void Toolbox::on_copyFramesIndex_valueChanged(int arg1)
{

}
*****

***** TOL_EDITOR\toolbox.cpp

/**
 * Function to retranslate the user interface
 */
void Toolbox::retranslateUi(QWidget *Toolbox)
{
    Toolbox->setWindowTitle(QApplication::translate("Toolbox", "Toolbox", 0));
    tabWidget->setTabText(tabWidget->indexOf(tab), QApplication::translate("Toolbox", "Color", 0));
    label->setText(QApplication::translate("Toolbox", "                     Start", 0));
    label_6->setText(QString());
    label_2->setText(QApplication::translate("Toolbox", "                      End", 0));
    label_5->setText(QString());
    addFramesButton->setText(QApplication::translate("Toolbox", "Add Frames", 0));
    label_9->setText(QApplication::translate("Toolbox", "                      First", 0));
    label_10->setText(QString());
    label_7->setText(QApplication::translate("Toolbox", "                      Last", 0));
    label_11->setText(QString());
    removeFramesButton->setText(QApplication::translate("Toolbox", "Remove Frames", 0));
    label_4->setText(QApplication::translate("Toolbox", "              Frame", 0));
    label_12->setText(QString());
    label_3->setText(QApplication::translate("Toolbox", "               Start", 0));
    label_13->setText(QString());
    label_8->setText(QApplication::translate("Toolbox", "               End", 0));
    label_14->setText(QString());
    copyFramesButton->setText(QApplication::translate("Toolbox", "Copy Frames", 0));
    label_15->setText(QApplication::translate("Toolbox", "                             Current Time", 0));
    currentTime->setDisplayFormat(QApplication::translate("Toolbox", "h:mm.ss", 0));
    label_23->setText(QString());
    label_21->setText(QString());
    label_19->setText(QString());
    label_17->setText(QString());
    label_16->setText(QApplication::translate("Toolbox", "                             Time interval", 0));
    timeInterval->setDisplayFormat(QApplication::translate("Toolbox", "h:mm.ss", 0));
    label_24->setText(QString());
    label_22->setText(QString());
    label_20->setText(QString());
    label_18->setText(QString());
    tabWidget->setTabText(tabWidget->indexOf(tab_2), QApplication::translate("Toolbox", "Editing", 0));
} // retranslateUi

void Toolbox::setupUiColorDialogue(){
    tabWidget->setCurrentIndex(0);

    dialog = new QColorDialog(this->tab);
    dialog->setWindowFlags(Qt::SubWindow);
    dialog->setOptions(QColorDialog::DontUseNativeDialog | QColorDialog::NoButtons);
    dialog->move(0,50);
}
***** TOL_EDITOR_MASTER\toolbox.cpp

void Toolbox::on_copyFramesButton_clicked()
{

}

void Toolbox::colorChanged()
{

}
*****

***** TOL_EDITOR\toolbox.cpp

/**
 * Signal Function Stubs
 */
void Toolbox::on_addFramesEnd_valueChanged(int arg1)
{

}

void Toolbox::on_addFramesStart_valueChanged(int arg1)
{

}

void Toolbox::on_addFramesButton_clicked()
{

}

void Toolbox::on_removeFramesStart_valueChanged(int arg1)
{

}

void Toolbox::on_removeFramesEnd_valueChanged(int arg1)
{

}

void Toolbox::on_removeFramesButton_clicked()
{

}

void Toolbox::on_copyFramesStart_valueChanged(int arg1)
{

}

void Toolbox::on_copyFramesEnd_valueChanged(int arg1)
{

}

void Toolbox::on_copyFramesIndex_valueChanged(int arg1)
{

}

void Toolbox::on_copyFramesButton_clicked()
{

}

void Toolbox::colorChanged()
{

}
***** TOL_EDITOR_MASTER\toolbox.cpp
*****

Comparing files TOL_EDITOR\toolbox.h and TOL_EDITOR_MASTER\toolbox.h
***** TOL_EDITOR\toolbox.h
#include <QtWidgets/QButtonGroup>
#include <QtWidgets/QHBoxLayout>
***** TOL_EDITOR_MASTER\toolbox.h
#include <QtWidgets/QButtonGroup>
#include <QtWidgets/QGridLayout>
#include <QtWidgets/QHBoxLayout>
*****

***** TOL_EDITOR\toolbox.h
#include <QtWidgets/QHeaderView>
#include <QtWidgets/QLabel>
#include <QtWidgets/QPushButton>
***** TOL_EDITOR_MASTER\toolbox.h
#include <QtWidgets/QHeaderView>
#include <QtWidgets/QPushButton>
*****

***** TOL_EDITOR\toolbox.h
#include <QtWidgets/QTabWidget>
#include <QtWidgets/QTimeEdit>
#include <QtWidgets/QVBoxLayout>
#include <QtWidgets/QWidget>
***** TOL_EDITOR_MASTER\toolbox.h
#include <QtWidgets/QTabWidget>
#include <QtWidgets/QWidget>
*****

***** TOL_EDITOR\toolbox.h
#include <QColorDialog>

***** TOL_EDITOR_MASTER\toolbox.h
#include <QColorDialog>
#include <QObject>
#include <QWidget>

*****

***** TOL_EDITOR\toolbox.h
    QWidget *tab_2;
    QWidget *widget;
    QVBoxLayout *verticalLayout_10;
    QHBoxLayout *horizontalLayout;
    QVBoxLayout *verticalLayout;
    QLabel *label;
    QSpinBox *addFramesStart;
    QLabel *label_6;
    QVBoxLayout *verticalLayout_2;
    QLabel *label_2;
    QSpinBox *addFramesEnd;
    QLabel *label_5;
    QPushButton *addFramesButton;
    QHBoxLayout *horizontalLayout_2;
    QVBoxLayout *verticalLayout_3;
    QLabel *label_9;
    QSpinBox *removeFramesStart;
    QLabel *label_10;
    QVBoxLayout *verticalLayout_4;
    QLabel *label_7;
    QSpinBox *removeFramesEnd;
    QLabel *label_11;
    QPushButton *removeFramesButton;
    QHBoxLayout *horizontalLayout_3;
    QVBoxLayout *verticalLayout_5;
    QLabel *label_4;
    QSpinBox *copyFramesIndex;
    QLabel *label_12;
    QVBoxLayout *verticalLayout_6;
    QLabel *label_3;
    QSpinBox *copyFramesStart;
    QLabel *label_13;
    QVBoxLayout *verticalLayout_7;
    QLabel *label_8;
    QSpinBox *copyFramesEnd;
    QLabel *label_14;
    QPushButton *copyFramesButton;
***** TOL_EDITOR_MASTER\toolbox.h
    QWidget *tab_2;
    QGridLayout *gridLayout_3;
    QHBoxLayout *horizontalLayout_5;
    QSpinBox *addFramesStart;
    QSpinBox *addFramesEnd;
    QPushButton *addFramesButton;
    QHBoxLayout *horizontalLayout_3;
    QHBoxLayout *horizontalLayout_2;
    QSpinBox *copyFramesStart;
    QSpinBox *copyFramesEnd;
    QHBoxLayout *horizontalLayout;
    QSpinBox *copyFramesIndex;
    QPushButton *copyFramesButton;
*****

***** TOL_EDITOR\toolbox.h
    QHBoxLayout *horizontalLayout_4;
    QVBoxLayout *verticalLayout_8;
    QLabel *label_15;
    QTimeEdit *currentTime;
    QLabel *label_23;
    QLabel *label_21;
    QLabel *label_19;
    QLabel *label_17;
    QVBoxLayout *verticalLayout_9;
    QLabel *label_16;
    QTimeEdit *timeInterval;
    QLabel *label_24;
    QLabel *label_22;
    QLabel *label_20;
    QLabel *label_18;
    QColorDialog *dialog;
***** TOL_EDITOR_MASTER\toolbox.h
    QHBoxLayout *horizontalLayout_4;
    QSpinBox *removeFramesStart;
    QSpinBox *removeFramesEnd;
    QPushButton *removeFramesButton;
    QColorDialog *dialog;
*****

***** TOL_EDITOR\toolbox.h

    void setupUiTabs(QWidget *Toolbox);

    void setupUiMasterWidget();

    void setupUiLabels(QWidget *widget);

    void setupUiWidgets(QWidget *widget);

    void setupUiLayouts(QWidget *widget);

    void setupUiColorDialogue();

    void retranslateUi(QWidget *Toolbox);
***** TOL_EDITOR_MASTER\toolbox.h

    void retranslateUi(QWidget *Toolbox);
*****

